<!doctype html>
<html lang="en_US">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"> 
    <title>#3</title>
    <style>
      H2 { text-align: center }
    </style>
  </head>

  <body>
    <h2>#3</h2>
    <p>Last modified 2023 February 15</p>

    <h3>Purpose:</h3>
    To go over:
    <ul>
      <li>The theory top-down parsing</li>
      <li>javacc</li><h2></h2>
    </ul>
    <p/>

    <h3>Task:</h3>
    <p>
      Consider a natural language called <em>Nihonglish</em> with the vocabulary of English but a different grammar.
      <ul>
	<li>
	  The grammar of Nihonglish does not have have <em>pre</em>positions or <em>pre</em>positional phrases.
	  Instead, it has <em>post</em>positions and <em>post</em>positional phrases.
	</li>
	<li>
	  The topic of the sentence (often times the subject),
	  has its own post-position:
	  <em>&quot;as for&quot;</em>
	</li>
	<li>
	  the verb comes at the end.
	</li>
      </ul>
    </p>
    <p>
      The English sentence:
      <pre>I am going home.</pre>
      is rendered in Nihonglish as:
      <pre>I as for home to going.</pre>
      And the question
      <pre>Are you going to the store?</pre>
      is rendered in Nihonglish as:
      <pre>You as for store to going?</pre>
      or more succinctly:
      <pre>Store to going?</pre>
    </p>
    <p>
      Our subset of Nihonglish has these non-terminals:
      <table border="1">
	<tr><th>Non-Terminal</th><th>Meaning</th></tr>
	<tr><td>S</td><td>sentence</td></tr>
	<tr><td>PPL</td><td>post-positional phrase list</td></tr>
	<tr><td>PP</td><td>post-positional phrase</td></tr>
	<tr><td>T</td><td>topic</td></tr>
	<tr><td>L</td><td>location</td></tr>
      </table>
      and these grammatical rules:
      <ol type="1">
	<li>S -&gt; PPL going period</li>
	<li>S -&gt; PPL going question_mark</li>
	<li>PPL -&gt; PP PP*</li>
	<li>PP -&gt; T as for</li>
	<li>T -&gt; i (The English 1st person pronoun <em>&quot;I&quot;</em>)</li>
	<li>T -&gt; you</li>
	<li>PP -&gt; L to</li>
	<li>L -&gt; home</li>
	<li>L -&gt; store</li>
      </ol>
    </p>

    <h3>You must:</h3>
    <p>
      <ol type="1">
	<li>
	  (80 Points)
	  <p>
	    Give <code>nihonglish.jj</code> both
	    the tokens (uppercase and lowercase) of the English words,
	    and the grammar rules to parse Nihonglish.
	  </p>
	  <p>
	    I have already already given you the following classes and interfaces:
	    <ul>
	      <li><code>Sentence.java</code>,</li>
	      <li><code>Phrase.java</code>,</li>
	      <li><code>SubjectPhrase.java</code>,</li>
	      <li><code>ToPhrase.java</code>,</li>
	    </ul>
	  </p>
	  <p>
	    You have to:
	    <ol type="a">
	      <li>
		Define the terminals
		(they are called <code>TOKEN</code>s in Javacc).
	      </li>
	      <li>
		Define the grammar rules in <code>Nihonglish.jj</code>.
	      </li>
	    </ol>
	  </p>
	  <p>
	    What this program does is restate the Nihonglish sentences into ordinary English:
	    <pre>$ <strong>javacc.sh Nihonglish.jj</strong>
Java Compiler Compiler Version 5.0 (Parser Generator)
(type &quot;javacc&quot; with no arguments for help)
Reading from file Nihonglish.jj . . .
File &quot;TokenMgrError.java&quot; is being rebuilt.
File &quot;ParseException.java&quot; is being rebuilt.
File &quot;Token.java&quot; is being rebuilt.
File &quot;SimpleCharStream.java&quot; is being rebuilt.
Parser generated successfully.
$ <strong>javac Nihonglish.java </strong>
$ <strong>java Nihonglish</strong>
Sentence to parse or &quot;&quot; to quit: <strong>I as for home to going.</strong>
I am going to home.

Sentence to parse or &quot;&quot; to quit: <strong>I as for home to going?</strong>
Am I going home?

Sentence to parse or &quot;&quot; to quit: <strong>Home to I as for going.</strong>
I am going to home.

Sentence to parse or &quot;&quot; to quit: <strong>Home to going.</strong>
I am going to home.

Sentence to parse or &quot;&quot; to quit: <strong>Store to going.</strong>
I am going to the store.

Sentence to parse or &quot;&quot; to quit: <strong>Store to you as for going.</strong>
You are going to the store.

Sentence to parse or &quot;&quot; to quit: <strong>You as for going?</strong>
Are you going?

Sentence to parse or &quot;&quot; to quit: <strong>You as for home to going.</strong>
You are going to home.

Sentence to parse or &quot;&quot; to quit: <strong>(I just pressed &quot;Enter&quot;)</strong>
</pre>
	  </p>
	  <p>
	    So let us go!
	    <ol type="a">
	      <li>
		<code>Sentence.java</code>
		<pre>/*-------------------------------------------------------------------------*
 *---									---*
 *---		Sentence.java						---*
 *---									---*
 *---	    This file defines a class representing a sentence composed	---*
 *---	of 1 or 2 phrase, the present-tense verb &quot;to go&quot; that is either	---*
 *---	in a question or declarative form.		      	 	---*
 *---									---*
 *---	----	----	----	----	----	----	----	----	---*
 *---									---*
 *---	Version 1a	2023 December 6		Joseph Phillips		---*
 *---									---*
 *-------------------------------------------------------------------------*/

class	Sentence
{
  //  I.  Member vars:
  //  PURPOSE:  To refer to the topic phrase, if one is given.
  private
  SubjectPhrase			asFor_		= null;

  //  PURPOSE:  To refer to the location phrase, if one is given.
  private
  ToPhrase			to_		= null;

  //  PURPOSE:  To hold 'true' if '*this' represents a question or 'false'
  //	if '*this' represents a declarative sentence.
  private
  boolean			isAQuestion_	= false;

  //  II.  Protected methods:
  //  PURPOSE:  To attach phrase 'phrase' to '*this' Sentence.
  //	No return value.
  protected
  void		attach		(SubjectPhrase		phrase
				)
  {
    if  (phrase != null)
    {
      if  (asFor_ != null)
      {
	System.err.println(&quot;Ambiguity: 2 people mentioned.&quot;);
	System.exit(1);
      }

      asFor_	= phrase;
    }
  }

  //  PURPOSE:  To attach phrase 'phrase' to '*this' Sentence.
  //	No return value.
  protected
  void		attach		(ToPhrase		phrase
				)
  {
    if  (phrase != null)
    {
      if  (to_ != null)
      {
	System.err.println(&quot;Ambiguity: 2 places mentioned.&quot;);
	System.exit(1);
      }

      to_	= phrase;
    }
  }

  //  III.  Constructor(s), assignment op(s), factory(s) and destructor:
  //  PURPOSE:  To initialize 'this' Sentence with the list of phrases given
  //	in 'phrase' to be a question if 'isAQuestion' is 'true' or a
  //	declarative sentence otherwise.  No return value.
  public
  Sentence			(Phrase		phrase,
				 boolean	isAQuestion
				)
  {
    isAQuestion_	= isAQuestion;

    if  (phrase != null)
    {
      if  (phrase instanceof SubjectPhrase)
      {
	attach((SubjectPhrase)phrase);
      }
      else
      if  (phrase instanceof ToPhrase)
      {
	attach((ToPhrase)phrase);
      }

      if  (phrase.getNext() != null)
      {
	if  (phrase.getNext() instanceof SubjectPhrase)
	{
	  attach((SubjectPhrase)phrase.getNext());
	}
	else
	if  (phrase.getNext() instanceof ToPhrase)
	{
	  attach((ToPhrase)phrase.getNext());
      	}
      }
    }
  }

  //  V.  Accessors:

  //  VI.  Mutators:

  //  VII.  Methods that do the main and misc work of the class:
  //  PURPOSE:  To compose and return a string representation of 'this'
  //  	Sentence in conventional English.
  public
  String	toString	()
  {
    StringBuffer	buf	= new StringBuffer();

    if  (isAQuestion_)
    {
      if  ( (asFor_ == null)  ||  (asFor_.toString() == &quot;you&quot;) )
	buf.append(&quot;Are you going&quot;);
      else
	buf.append(&quot;Am I going&quot;);

      if  (to_ != null)
      {
	buf.append(&quot; &quot; + to_.toString() + &quot;?\n&quot;);
      }
      else
	buf.append(&quot;?\n&quot;);
    }
    else
    {
      if  ( (asFor_ == null)  ||  (asFor_.toString() == &quot;I&quot;) )
	buf.append(&quot;I am going&quot;);
      else
	buf.append(&quot;You are going&quot;);

      if  (to_ != null)
      {
	buf.append(&quot; to &quot; + to_.toString() + &quot;.\n&quot;);
      }
      else
	buf.append(&quot;.\n&quot;);
    }

    return(buf.toString());
  }

}</pre>
	      </li>
	      <li>
		<code>Phrase.java</code>
		<pre>/*-------------------------------------------------------------------------*
 *---									---*
 *---		Phrase.java						---*
 *---									---*
 *---	    This file defines an interface of phrases in a Sentence.	---*
 *---	The phrases are kind of equivalent to prepositional phrases.	---*
 *---									---*
 *---	----	----	----	----	----	----	----	----	---*
 *---									---*
 *---	Version 1a	2023 December 6		Joseph Phillips		---*
 *---									---*
 *-------------------------------------------------------------------------*/

//  PURPOSE:  To serve as the interface for all phrases.
public
interface	Phrase
{
  //  PURPOSE:  To return the reference to the next phrase, if there is one.
  //	No parameters.
  public
  Phrase	getNext		();

  //  PURPOSE:  To make 'next' the phrase after '*this' one.  No return value.
  public
  void		attach		(Phrase		next
				);

}</pre>
	      </li>
	      <li>
		<code>SubjectPhrase.java</code>
		<pre>/*-------------------------------------------------------------------------*
 *---									---*
 *---		SubjectPhrase.java					---*
 *---									---*
 *---	    This file defines a class representing phrases telling	---*
 *---	the subject of a sentence.					---*
 *---									---*
 *---	----	----	----	----	----	----	----	----	---*
 *---									---*
 *---	Version 1a	2023 December 6		Joseph Phillips		---*
 *---									---*
 *-------------------------------------------------------------------------*/

public
class	SubjectPhrase implements Phrase
{
  //  I.  Member vars:
  //  PURPOSE:  To hold the what or whom.
  private
  String			str_		= &quot;&quot;;

  //  PURPOSE:  To hold the next phrase in the list, if there is one.
  private
  Phrase			next_		= null;

  //  II.  Protected methods:

  //  III.  Constructor(s), assignment op(s), factory(s) and destructor:
  //  PURPOSE:  To make a phrase the represents &quot;asFor *newStr&quot;.
  //	No return value.
  public
  SubjectPhrase			(String		newStr
				)
				{
				    str_	= newStr;
				}

  //  IV.  Accessors:
  //  PURPOSE: To return the name of what or whom.  No parameters.
  public
  String	toString	()
				{ return(str_); }

  //  PURPOSE: To return the address of the next phrase, or 'NULL' if there is
  //	none.  No parameters.
  public
  Phrase	getNext		()
				{ return(next_); }

  //  V.  Mutators:
  //  PURPOSE:  To make 'next' the phrase after '*this' one.
  //	No return value.
  public
  void		attach		(Phrase		next
				)
				{
				  next_	= next;
				}

}</pre>
	      </li>
	      <li>
		<code>ToPhrase.java</code>
		<pre>/*-------------------------------------------------------------------------*
 *---									---*
 *---		ToPhrase.java						---*
 *---									---*
 *---	    This file defines a class representing phrases telling	---*
 *---	&quot;to where&quot;.							---*
 *---									---*
 *---	----	----	----	----	----	----	----	----	---*
 *---									---*
 *---	Version 1a	2023 December 6		Joseph Phillips		---*
 *---									---*
 *-------------------------------------------------------------------------*/

//  PURPOSE:  To represent phrase telling where to.
public
class	ToPhrase implements Phrase
{
  //  I.  Member vars:
  //  PURPOSE:  To hold the location.
  private
  String			str_	= &quot;&quot;;

  //  PURPOSE:  To hold the next phrase in the list, if there is one.
  private
  Phrase			next_	= null;

  //  II.  Protected methods:

  //  III.  Constructor(s) and factory(s):
  //  PURPOSE:  To make a phrase the represents &quot;to newStr&quot;.
  //	No return value.
  public
  ToPhrase			(String		newStr
				)
				{
				  str_	= newStr;
				}

  //  IV.  Accessors:
  //  PURPOSE: To return the name of the place.  No parameters.
  public
  String	toString	()
				{ return(str_); }

  //  PURPOSE: To return the next phrase, or 'null' if there is none.
  //	No parameters.
  public
  Phrase	getNext		()
				{ return(next_); }

  //  V.  Mutators:
  //  PURPOSE:  To make 'next' the phrase after 'this' one.  No return value.
  public
  void		attach		(Phrase		next
				)
				{ next_	= next; }

}</pre>
	      </li>
	      <li>
		<code>Nihonglish.jj</code>:
		<pre>PARSER_BEGIN(Nihonglish)

import	java.util.*;
import	java.io.*;

public
class	Nihonglish
{
    public
    static
    String	QUIT_CMD	= &quot;&quot;;

    static
    Nihonglish	parser	= null;

    public
    static
    Sentence	parse		(String	parseMe
    				)
				throws Exception
    {
      StringReader	input	= new java.io.StringReader(parseMe);

      if  (parser == null)
        parser	= new Nihonglish(input);
      else
	parser.ReInit(input);

      return(parser.sentence());
    }


    public
    static
    void	main(String[] args) throws Exception
    {
      String	parseMe;
      Scanner	input	= new Scanner(System.in);

      while (true)
      {
	System.out.print
		(&quot;Sentence to parse or \&quot;&quot;	+
		 QUIT_CMD			+
		 &quot;\&quot; to quit: &quot;
		);

	parseMe	= input.nextLine();

	if  ( parseMe.equals(QUIT_CMD) )
	{
	  break;
	}

	try
	{
          System.out.println(parse(parseMe));
        }
        catch (Exception error)
        {
	  System.err.println(error);
	}
      }
    }
}

PARSER_END(Nihonglish)

SKIP:	{ &quot; &quot; | &quot;\t&quot; | &quot;\n&quot; | &quot;\r&quot; }
TOKEN:	{ <strong>/* DELETE THIS AND DEFINE TOKENS HERE */</strong>
	}


Sentence	sentence	() throws Exception :
{
  Sentence	sent;
  Phrase	phrase;
  boolean	isQuestion;
}
{
  <strong>// DELETE THIS AND ADD CODE HERE</strong>
  { return(null <strong>/* DELETE null AND ADD CODE HERE */</strong>); }
}


Phrase		postposit_phrase_list	() throws Exception :
{
  Phrase	phrase1st	= null;
  Phrase	phraseNth	= null;
}
{
  <strong>// DELETE THIS AND ADD CODE HERE</strong>
  { return(null <strong>/* DELETE null AND ADD CODE HERE */</strong>); }
}


Phrase		postposit_phrase	() throws Exception :
{
  Phrase	phrase	= null;
  String	who	= &quot;&quot;;
  String	where	= &quot;&quot;;
}
{
  <strong>// DELETE THIS AND ADD CODE HERE</strong>
  { return(null <strong>/* DELETE null AND ADD CODE HERE */</strong>); }
}


String		who	() throws Exception :
{
  String	s;
}
{
  <strong>// DELETE THIS AND ADD CODE HERE</strong>
  { return(null <strong>/* DELETE null AND ADD CODE HERE */</strong>); }
}


String		where	() throws Exception :
{
  String	s;
}
{
  <strong>// DELETE THIS AND ADD CODE HERE</strong>
  { return(null <strong>/* DELETE null AND ADD CODE HERE */</strong>); }
}</pre>
	      </li>
	    </ol>
	  </p>
	</li>
	<p/>
	<li>
	  (20 Points)
	  <p>
	    Notice the grammar rule:
	    <pre>
3. PPL -&gt; PP PP*</pre>
	    This is a bit too general because,
	    in this simple grammar,
	    there can only be either 1 or 2 post-position phrases.
	  </p>
	  <p>
	    An alternative is define the following grammar:
	    <pre>
3a. PPL -&gt; PP
3b. PPL -&gt; PP PP</pre>
	    What happens when you try to define such a grammar in Javacc?
	</li>

      </ol>
    </p>
  </body>
  
</html>
